(1) What did you plan on doing?
	We planned on implementing three types of garbage collection algorithms (Mark-And-Sweep, Mark-And-Compact, and Copying Collector) and heap optimizations 
    for each. Afterwards, we planned on comparing the results between the three algorithms. We planned on making stress tests to see time and memory 
    efficiency of each algorithm.

(2) What did you end up doing?
	We ended up implementing Mark-And-Sweep and Copying Collector with heap optimizations for both. In order to do this, we had to change heap.cc to fit our 
    garbage collection algorithms. In heap.cc, we made personalized malloc and free methods. For example, in copying collector, we divide the heap into two 
    space: “from space” & “to space,” only allocating in the “from space”. Then, we mark all the roots and traverse from the root to all reachable objects. 
    As we accessed each object, we copied it from the “from space” to the “to space”. As we copy each object, we also had to update all the references for 
    the child objects of the object. This process of copying objects and updating references, we implemented recursively. Once we copied all the object from 
    the “from space” to the “to space” and updated references, we flip the “from space” and the “to space”. Now, the old “from space” only contained garbage 
    so we could sweep it. Similarly, for mark and sweep. For both of these, we implemented a stress test to gauge how much memory we ended up freeing with 
    each algorithm and how much fragmentation we had. Since we are in an emulated environment, we couldn’t just simply do this with Valgrind. Instead, we 
    implemented methods to see how the heap looked and we manually kept track of each allocation and deallocation, having explicit control over object 
    lifecycle as the kernel is acting as it’s own garbage collector in this case.

[explain marking? Keeping track of live objects? Object meta? Accessing roots global variables and how we had to do it assembly]

(3) What did you learn?
	Through the challenges of this project, we learned quite a bit of valuable lessons. First of all–and the most obvious–we gained a deep understanding of 
    the garbage collection process. Before this project, we didn’t have much idea about the different types of garbage collection (mark and sweep, mark and 
    compact, copying collector) and how they can be done (generational, concurrent). However, through research and solving problems, we learned the complex 
    steps of garbage collection. More specifically, we kernel level garbage collection. Working on the kernel level brought many more challenges than we 
    expected in terms of garbage collection. However, solving these challenges deepened our understanding of coding in a performance-critical environment 
    and opened our eyes on the ongoing debate of kernel level garbage collection within the Operating Systems community. Due to issues like the impact on 
    system responsiveness, overhead introduced due to garbage collection algorithms, and the pros and cons of pause times and efficiency. Furthermore, we 
    also gained a deeper understanding of memory management. By implementing different garbage collection algorithms, we were able to see how different 
    algorithms could create or lessen the fragmentation. Working so closely with each allocation and deallocation, we were able to learn about how garbage 
    collectors manage the lifecycle of objects, efficiently using memory. This involved for us to develop techniques of accurate marking and tracking in 
    low-level system programming and assembly.

(4) How much did each team member contribute?
	Each group member contributed equally to the project. One person implemented the Mark And Sweep garbage collection algorithm while the other implemented 
    the Copying Collector garbage collection algorithm. We did everything else together collaborating at the same time (reports, test cases, presentation, etc.).

(5) How can we get/run your code?
	If you want to run Mark And Sweep, type the following into the terminal:
	make USE_MARK_AND_SWEEP=1 t0.test
	If you want to run Copying Collector, type the following into the terminal:
	make t0.test

